! This the manifest file for the Parchment in-browser interpreter, and gives
! the necessary details to Inform's release component (called cBlorb) so that
! the interpreter can be bundled into a released website, all set up ready
! to play the IF story file being released.

! Manifest files have a simple format. They are allowed to set the value of
! any cBlorb placeholders that they would like to, but the ones below are the
! only ones they will likely want to set. These two are needed for the footer
! of the play page:

[INTERPRETERVERSION]
Vorple
[]

[INTERPRETERURL]
https://vorple-if.com
[]

! Note that we don't set [INTERPRETER]: cBlorb has already set that to the
! name of the interpreter, in this case, to "Vorple".

! This declares whether the interpreter can handle blorbed Z-machine files
! ("z"), blorbed Glulx files ("g") or both ("zg" or "gz"). No other values
! are legal; note lower case.

[INTERPRETERVM]
g
[]

! [INTERPRETERHEAD] provides code to go into the <head> ... </head> of the
! web page playing the work. (Placeholder text starts on the line after the
! name, and continues until a line reads just []. Line breaks are included
! between lines, though not at the end of the final line; white space is
! stripped out at the left and right hand edges of each line.)

! In writing the head and body, note that the structure of the site being
! constructed is:
!     play.html  <-- page on which the interpreter runs
!     interpreter
!         ...the base64-encoded story file...
!         ...any files copied over according to the manifest below...
! The placeholder [ENCODEDSTORYFILE] expands to the leafname of the base64
! version of the story file, which might be (but should not be assumed
! to be) "story.zblorb.js".

[INTERPRETERHEAD]
<link rel="apple-touch-icon" sizes="180x180" href="/terra-nova/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/terra-nova/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/terra-nova/favicon-16x16.png">
<link rel="manifest" href="/terra-nova/site.webmanifest">
<link rel="shortcut icon" type="image/x-icon" href="/terra-nova/favicon.ico">
    <meta name="robots" content="noindex, nofollow">
    <meta name="googlebot" content="noindex, nofollow">
    <meta name="robots" content="noimageindex">
    <meta name="robots" content="noarchive">
    <meta name="robots" content="nocache">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" type="text/css" href="interpreter/roboto.css">
    <link rel="stylesheet" type="text/css" href="interpreter/jquery.powertip.css">
    <link rel="stylesheet" type="text/css" href="interpreter/toastr.css">
    <link rel="stylesheet" type="text/css" href="interpreter/vex.css">
    <link rel="stylesheet" type="text/css" href="interpreter/vex-theme-plain.css">

    <link rel="stylesheet" type="text/css" href="interpreter/haven.css">
    <link rel="stylesheet" type="text/css" href="interpreter/vorple.css">
<style>
/* Center the vex-content dialog */
.vex-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    /* Optionally, add some width to prevent it from being too small */
    width: auto; /* Adjust or set a fixed width if needed */
    max-width: 90%; /* Optional, ensures it doesn't go beyond the screen size */
    box-sizing: border-box; /* Ensures padding is included in width calculation */
}
</style>

[]

! [INTERPRETERBODY] provides the part of the page where the window
! or gadget actually appears.

[INTERPRETERBODY]
  <main id="vorple">
    <div id="loader">
      <h2 id="loader-message">Loading scripts</h2>
      <div id="spinner">V</div>
    </div>
  </main>

  <script src="interpreter/vorple.min.js"></script>
  <script src="interpreter/[ENCODEDSTORYFILE]"></script>

  <script>
    if( location.protocol === "file:" ) {
      $( 'body' )
        .empty()
        .html( "<div><p>You are currently viewing the page from the filesystem. " +
          "Unfortunately Vorple requires that the page is viewed through " +
          "the HTTP protocol, that is, you'll need to either upload it " +
          "to the Internet or install a local server.</p>" +
          '<p>See <a href="https://vorple-if.com/docs/localhost" style="color:#dde">vorple-if.com/docs/localhost</a> ' +
          "for more information.</p>" +
          "</div>" )
        .find( 'div' )
        .css({
          margin: "2em",
          padding: "1em",
          color: "#fff",
          backgroundColor: "rgb(137, 50, 58)",
          border: "3px solid gray"
        });

      throw new Error( "Vorple can't be run from the filesystem" );
    }

    $( function() {
      $( '.container, .interpretercredit' ).remove();
    });

    vorple.options = {
      autosave: false,
      engineColors: false,
      story: ""
    };

    vorple.debug.off();
    vorple.init();

  </script>

<script>
// Complete Audio Manager System with async support, volume control,
// and automatic cleanup of completed sounds
class AudioManager {
    constructor() {
        this.activeAudio = new Map();
        this.fadeOutDuration = 500;
        this.pendingOperations = new Map();
    }

    async playSound(audible, audioHandle, filePath, loopCount = 1, initialVolume = 1, delay = 0) {
        if (this.pendingOperations.has(audioHandle)) {
            clearTimeout(this.pendingOperations.get(audioHandle));
            this.pendingOperations.delete(audioHandle);
        }

        if (delay === 0) {
            return this.playSoundNow(audible, audioHandle, filePath, loopCount, initialVolume);
        }

        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(async () => {
                this.pendingOperations.delete(audioHandle);
                try {
                    const result = await this.playSoundNow(audible, audioHandle, filePath, loopCount, initialVolume);
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
            }, delay);

            this.pendingOperations.set(audioHandle, timeoutId);
        });
    }

    async playSoundNow(audible, audioHandle, filePath, loopCount, initialVolume) {
        const operationId = Symbol();

        if (audible == 'off' || filePath.toLowerCase().includes("silence")) {
            if (this.activeAudio.has(audioHandle)) {
                await this.fadeOutAndStop(audioHandle);
            }
            return audioHandle;
        }

        if (this.activeAudio.has(audioHandle)) {
            const currentAudio = this.activeAudio.get(audioHandle);
            if (currentAudio.filePath === filePath) {
                return audioHandle;
            }
            await this.fadeOutAndStop(audioHandle);
        }

        const audio = new Audio(filePath);
        audio.volume = Math.max(0, Math.min(1, initialVolume));
        let playCount = 0;

        // For infinite or multiple loops
        if (loopCount === -1 || loopCount > 1) {
            audio.addEventListener('ended', () => {
                if (this.activeAudio.has(audioHandle)) {
                    if (loopCount !== -1) {
                        playCount++;
                        if (playCount >= loopCount) {
                            this.activeAudio.delete(audioHandle);
                            return;
                        }
                    }
                    audio.currentTime = 0;
                    audio.play().catch(error => console.error('Error restarting audio:', error));
                }
            });
        } else {
            // Single play
            audio.addEventListener('ended', () => {
                if (this.activeAudio.has(audioHandle)) {
                    this.activeAudio.delete(audioHandle);
                }
            });
        }

        this.activeAudio.set(audioHandle, {
            audio: audio,
            filePath: filePath,
            volume: initialVolume,
            loopCount: loopCount,
            playCount: 0,
            currentOperation: operationId
        });

        try {
            await audio.play();
        } catch (error) {
            console.error('Error playing audio:', audioHandle, error);
            this.activeAudio.delete(audioHandle);
            throw error;
        }

        return audioHandle;
    }

    stop(audioHandle) {
        if (this.pendingOperations.has(audioHandle)) {
            clearTimeout(this.pendingOperations.get(audioHandle));
            this.pendingOperations.delete(audioHandle);
        }

        if (this.activeAudio.has(audioHandle)) {
            const audioObj = this.activeAudio.get(audioHandle);
            audioObj.audio.pause();
            audioObj.audio.currentTime = 0;
            this.activeAudio.delete(audioHandle);
        }
    }

    stopAll() {
        for (const [handle, timeoutId] of this.pendingOperations.entries()) {
            clearTimeout(timeoutId);
        }
        this.pendingOperations.clear();

        for (const handle of this.activeAudio.keys()) {
            this.stop(handle);
        }
    }

    fadeOutAndStop(audioHandle) {
        if (this.pendingOperations.has(audioHandle)) {
            clearTimeout(this.pendingOperations.get(audioHandle));
            this.pendingOperations.delete(audioHandle);
        }

        return new Promise((resolve) => {
            if (this.activeAudio.has(audioHandle)) {
                const audioObj = this.activeAudio.get(audioHandle);
                if (!audioObj || !audioObj.audio) {
                    this.activeAudio.delete(audioHandle);
                    resolve();
                    return;
                }

                const audio = audioObj.audio;
                const originalVolume = audio.volume || 0;
                const fadeSteps = 20;
                const fadeInterval = this.fadeOutDuration / fadeSteps;

                let currentStep = 0;

                const fadeTimer = setInterval(() => {
                    currentStep++;
                    if (!this.activeAudio.has(audioHandle)) {
                        clearInterval(fadeTimer);
                        resolve();
                        return;
                    }

                    const newVolume = originalVolume * (1 - currentStep / fadeSteps);
                    audio.volume = Math.max(0, newVolume);

                    if (currentStep >= fadeSteps) {
                        clearInterval(fadeTimer);
                        this.stop(audioHandle);
                        resolve();
                    }
                }, fadeInterval);
            } else {
                resolve();
            }
        });
    }

    isPlaying(audioHandle) {
        return this.activeAudio.has(audioHandle) &&
            !this.activeAudio.get(audioHandle).audio.paused;
    }

    setVolume(audioHandle, volume) {
        if (this.activeAudio.has(audioHandle)) {
            const audioObj = this.activeAudio.get(audioHandle);
            audioObj.audio.volume = Math.max(0, Math.min(1, volume));
        }
    }
}
</script>

<script>
// Create a hidden canvas element at page load
const hiddenCanvas = document.createElement('canvas');
hiddenCanvas.style.display = 'none';
document.body.appendChild(hiddenCanvas);   
const hiddenCtx = hiddenCanvas.getContext('2d');

// set up audio
var audioManager = new AudioManager();

function setupMobileContinue() {
    // Create a continue button
    let continueBtn = document.createElement('button');
    continueBtn.innerText = 'Continue';
    continueBtn.style.position = 'fixed';
    continueBtn.style.bottom = '20px';
    continueBtn.style.left = '50%';
    continueBtn.style.transform = 'translateX(-50%)';
    continueBtn.style.padding = '10px 20px';
    continueBtn.style.display = 'none';  // Hidden by default
    document.body.appendChild(continueBtn);

    // Monitor for the "Press SPACE to continue" message
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.addedNodes.length) {
                if (document.body.innerText.includes("Press SPACE to Continue.")) {
                    continueBtn.style.display = 'block';
                }
            }
        });
    });

    // Watch for DOM changes
    observer.observe(document.body, { childList: true, subtree: true });

    // When button is clicked, simulate a space keypress
    continueBtn.addEventListener('click', function() {
        const spaceEvent = new KeyboardEvent('keydown', {
            key: ' ',
            keyCode: 32,
            which: 32,
            bubbles: true
        });
        document.dispatchEvent(spaceEvent);
        continueBtn.style.display = 'none';
    });
}

function setBackgroundColorAndTextColor(rgb) {
  // Ensure the RGB value is a hexadecimal color code
  if (!rgb.startsWith('#')) {
    console.error('Invalid RGB value. Must start with "#"', rgb);
    return;
  }

  // Extract the hexadecimal color code
  const hexCode = rgb.substring(1);

  // Convert hexadecimal color code to RGB values
  const red = parseInt(hexCode.substring(0, 2), 16);
  const green = parseInt(hexCode.substring(2, 4), 16);
  const blue = parseInt(hexCode.substring(4, 6), 16);

  // Calculate luminance for contrast determination
  const luminance = (0.299 * red + 0.587 * green + 0.114 * blue) / 255;

  // Choose contrasting text color based on luminance
  let textColor = luminance > 0.5 ? "black" : "white";

  // Additional logic for more sophisticated color choices
  if (luminance > 0.7) {
    // For very light backgrounds, consider a darker shade of black
    textColor = "#333333";
  } else if (luminance < 0.3) {
    // For very dark backgrounds, consider a lighter shade of white
    textColor = "#cccccc";
  }

  // Set background and text colors
  document.getElementById('vorple').style.backgroundColor = rgb;
  let bs = document.getElementById('lineinput-field');
  if ( bs != null ) {
     bs.style.color = textColor;
     //bs.style.fontFamily = "Georgia";
  }

  bs = document.getElementById('lineinput-prefix');
  if ( bs != null ) {
     bs.style.backgroundColor = rgb;
     bs.style.color = textColor;
     //bs.style.fontFamily = "Georgia";
  }

   bs = document.getElementById('output');
   if ( bs != null ) {
      bs.style.backgroundColor = rgb;
      bs.style.color = textColor;
   }

   bs = document.getElementById('my_container');
   if ( bs != null ) {
      bs.style.backgroundColor = rgb;
      bs.style.color = textColor;
   }

   bs = document.getElementById('side_window');
   if ( bs != null ) {
      bs.style.backgroundColor = rgb;
      bs.style.color = textColor;
   }

   bs = document.getElementById('window0');
   if ( bs != null ) {
      bs.style.backgroundColor = rgb;
      bs.style.color = textColor;
   }

   bs = document.querySelector('.status-line-container');
   if ( bs != null ) {
      bs.style.backgroundColor = rgb;
      bs.style.color = textColor;
   }

  document.body.style.color = textColor;
  document.body.style.backgroundColor = rgb;
}

function getMostCommonRGB(image) {
  // Set canvas dimensions to match the image
  hiddenCanvas.width = image.width;
  hiddenCanvas.height = image.height;

  // Draw the image onto the hidden canvas
  hiddenCtx.drawImage(image, 0, 0);

  // Get the image data
  const imageData = hiddenCtx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
  const data = imageData.data;

  // Create a map to store RGB values and their frequencies
  const rgbMap = {};

  // Iterate over each pixel and increment the frequency of its RGB value
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const key = `${r},${g},${b}`;
    rgbMap[key] = (rgbMap[key] || 0) + 1;
  }

  // Find the most frequent RGB value
  let mostCommonRGB = null;
  let maxFrequency = 0;
  for (const key in rgbMap) {
    if (rgbMap[key] > maxFrequency) {
      mostCommonRGB = key;
      maxFrequency = rgbMap[key];
    }
  }

  let result = `#${mostCommonRGB.split(',').map(Number).map(v => v.toString(16).padStart(2, '0')).join('')}`;
  return result;
}

function updateImage(src, backgroundColor = 'default') {
   var sideWindow = document.getElementById('side_window');
   sideWindow.innerHTML = '<img src="' + src + ' "style="max-width:100%;height:auto;">';

   const image = new Image();
   image.src = src;

   image.onload = () => {
      let mostCommonRGB = getMostCommonRGB(image);
      if (backgroundColor != 'default' ) {
         mostCommonRGB = backgroundColor;   // override background color (rare)
      }
      const textColor = setBackgroundColorAndTextColor(mostCommonRGB);
   };
}

// These function all have to do with trying to RESTORE the interface after
// the user types 'restore' ... it is still imperfect, but pretty good.
var lastCmd;

// Function to return the last command the user typed
function getLastCommand() {
   let result = "none";
   if (lastCmd) {
      result = lastCmd;
   }
   //console.log("lastCmd:", result);
   return result; 
}

var restoreRequested;

// Function to return the last command the user typed
function checkRestore() {
   let result = restoreRequested;
   restoreRequested = 'no';  // reset to not fire 
   //console.log("checkRestore:", result);
   return (result && result == "yes");
}

document.addEventListener('DOMContentLoaded', function() {
    // Attach an event listener to the document (or a parent element) for keydown events
    document.body.addEventListener('keydown', function(event) {
        // Check if the target of the event is the dynamically created input field
        const inputField = document.getElementById('lineinput-field');
        
        if (inputField && event.target === inputField) {
            // Check if the pressed key is 'Enter' (key code 13)
            if (event.key === 'Enter' || event.keyCode === 13) {
                //event.preventDefault();  // Prevent the default form submission

                // Log the value of the input field to the console
                //console.log("Line input value:", inputField.value);
                lastCmd = inputField.value;
                if ( lastCmd.toLowerCase() == "restore" || lastCmd.toLowerCase() == "undo" ) {
                   restoreRequested = 'yes';
                }

            }
        }
    });
});

vorple.addEventListener('init', function() {
var containerDiv = document.createElement('div');
containerDiv.id = 'my_container';

// move side_window inside container
var sideWindow = document.createElement('div');
sideWindow.id = 'side_window';

// Move sideWindow & window0 into new container
var window0 = document.getElementById('window0');

containerDiv.appendChild(sideWindow);
containerDiv.appendChild(window0);

// move container inside output div
var outputDiv = document.getElementById('output');
outputDiv.appendChild(containerDiv);

// Adjust CSS styles as needed for layout
sideWindow.style.marginTop = '10px';
sideWindow.style.paddingTop = '10px';
sideWindow.style.paddingRight = '10px';

containerDiv.style.height = '95vh';
containerDiv.style.paddingTop = '10px';
containerDiv.style.marginTop = '10px';
containerDiv.style.display = 'grid';
containerDiv.style.gridTemplateColumns = '500px 1fr';

window0.style.overflowY= 'auto';
window0.style.paddingTop = '10px';
window0.style.paddingLeft = '10px';
window0.style.marginTop = '10px';

var playArea = document.getElementById('output');
playArea.style.maxWidth = '1400px';

playArea.style.margin = '0 auto';    // Center the container

var vorp = document.getElementById('vorple');
vorp.style.maxWidth = '1500px';
vorp.style.margin = '0 auto';    // Center the container

outputDiv.style.marginRight = '25px';

document.body.style.fontSize = "14pt";

// Trigger the event initially on page load
window.dispatchEvent(new Event('resize'));
});

window.addEventListener('resize', function() {
    const containerDiv = document.getElementById('my_container');
    const windowWidth = window.innerWidth;

    if (windowWidth < 600) {
        containerDiv.style.gridTemplateColumns = '0 1fr';  // Single column for small screens
        document.body.style.fontSize = "10pt";
    } else if (windowWidth < 1200) {
        containerDiv.style.gridTemplateColumns = '300px 1fr';  // Two columns, smaller left column
        document.body.style.fontSize = "12pt";
    } else {
        containerDiv.style.gridTemplateColumns = '500px 1fr';  // Original layout for larger screens
        document.body.style.fontSize = "16pt";
    }

   var statusLine = document.getElementById('status-line-container');
   if (statusLine) {
      statusLine.style.marginRight = '25px';

   }
});

// All our images
const imageArray = [
   'assembly-line-scale-1.jpg',
   'blackwood-portrait-3.jpg',
   'blast-off.gif',
   'blocked-tunnel-1.jpg',
   'blocked-tunnel-darker.jpg',
   'bot-assembly-4.jpg',
   'caretaker-closeup-4.jpg',
   'caretaker-peeps.jpg',
   'colony-monitor-1.jpg',
   'crumbling-ruins.jpg',
   'cyborg-agony-1.jpg',
   'cyborg-blocks-your-path-3.jpg',
   'cyborg-hybrid-1.jpg',
   'dark-tunnel.jpg',
   'dead-game-over-1.jpg',
   'dna-library-2.jpg',
   'docking-bay-normal-hand.jpg',
   'docking-bay-robotic-hand.jpg',
   'drone-attack-9.jpg',
   'drones-appear-1.jpg',
   'embrace-harmony-poster-rotated-1.jpg',
   'equipment-storage-3.jpg',
   'foundry-1.jpg',
   'future-village-5.jpg',
   'future-village-n.jpg',
   'hiroshi-portrait-1.jpg',
   'horizon-east.jpg',
   'horizon-north.jpg',
   'horizon-northeast.jpg',
   'horizon-northwest.jpg',
   'horizon-south.jpg',
   'horizon-southwest.jpg',
   'horizon-up-6.jpg',
   'horizon-west.jpg',
   'kai-as-beast-1.jpg',
   'kai-at-console-in-bay-1.jpg',
   'kai-captured-normal-hand.jpg',
   'kai-captured-robotic-hand.jpg',
   'kai-cyborg-5.jpg',
   'kai-exhibit-1.jpg',
   'kai-in-orbit-normal-hand.jpg',
   'kai-in-orbit-robotic-hand.jpg',
   'kai-in-well-c.jpg',
   'kai-is-grabbed-33.jpg',
   'kai-modified-2.jpg',
   'kai-new-hand-3.jpg',
   'kai-on-belt-f.jpg',
   'kai-on-bridge-1.jpg',
   'lab-with-caretaker-e.jpg',
   'lab-without-caretaker.jpg',
   'ladder-down-5a.jpg',
   'ladder-up-8.jpg',
   'lander-fff.jpg',
   'lander-interior-5.jpg',
   'lander-museum-z.jpg',
   'lava-pit-1.jpg',
   'legacy-bay-1.jpg',
   'legacy-bridge-2.jpg',
   'legacy-deep-space-11a.jpg',
   'legacy-deploys-zephyr-1.jpg',
   'legacy-docking-approach-5.jpg',
   'legacy-leaves-earth-55.jpg',
   'legacy-orbits-terra-nova-aa.jpg',
   'okafor-portrait-1.jpg',
   'parachute-2.jpg',
   'portal-view-of-terra-nova-3.jpg',
   'quantum-projector-1.jpg',
   'restricted-hallway-1.jpg',
   'restricted-hallway-beams-1.jpg',
   'ruins-solar-glass-1.jpg',
   'ruins-solar-glass-2.jpg',
   'settlement-1.jpg',
   'shadow-beast-attacks-3.jpg',
   'shrine-5.jpg',
   'splash-4.jpg',
   'stein-portrait-2.jpg',
   'stone-ruins-hide-2.jpg',
   'stone-tower-1.jpg',
   'stone-tower-interior-3.jpg',
   'sundown-1.jpg',
   'telescope-damaged-1.jpg',
   'tower-animation.gif',
   'tower-summit-4.jpg',
   'tunnel-2.jpg',
   'tunnel-3.jpg',
   'tunnel-beast-robot-3.jpg',
   'tunnel-beast-robot-freed-3.jpg',
   'unblocked-tunnel-b.jpg',
   'volcano-landscape-3.jpg',
   'well-1.jpg',
   'zephyrs-landing-ruins-6.jpg'
];

function preloadImages(imageFiles) {
    imageFiles.forEach(function(file) {
        const img = new Image();
        img.src = "img/" + file;
    });
}

console.error('Preloading images...');
preloadImages(imageArray);

// Preload audio files into browser cache
const soundFiles = [
    '119782__tremor.mp3',
    '156847__run-from-shadow-beast.mp3',
    '169553__climbing-rubble.mp3',
    '177958__water-drip-cave.mp3',
    '198300__emerging-from-well.mp3',
    '211683__legacy-docking-bay.mp3',
    '211683__research-lab.mp3',
    '315769__beast-growl.mp3',
    '32899__supply-room.mp3',
    '396062__well-dripping.mp3',
    '415609__lava-bubbles.mp3',
    '428740__page-turn.mp3',
    '434137__projector-blip.mp3',
    '449013__light-beams.mp3',
    '455068__guard-footsteps.mp3',
    '459838__docking-alert-beeps.mp3',
    '468442__smidglet-squeak.mp3',
    '505127__beast-roar.mp3',
    '535021__lame-caretaker-pursuit.mp3',
    '547472__wind-more.mp3',
    '56753__testing-station.mp3',
    '586384__alarm.mp3',
    '608439__wind-less.mp3',
    '609182__sleeping-beast.mp3',
    '625005__wind+birds.mp3',
    '688249__legacy-bridge.mp3',
    '71852__page-turn.mp3',
    '723973__absorbed.mp3',
    '724217__kai-in-orbit.mp3',
    '73607__assembly-line.mp3',
    '733261__cyborg-assembly.mp3', 
    '738438__beast-grunt-2.mp3', 
    '699928__beast-grunt-4.mp3', 
    '738439__beast-grunt-3.mp3', 
    '744790__beast-snores.mp3', 
    '738437__beast-grunt-1.mp3',
    '318320__beast-roar-2.mp3',
    '332520__beast-roar-big.mp3',
    '60085__rockslide.mp3',
    'terra-nova-ending-music.mp3',
    'terra-nova-intro.mp3'
];

function preloadSounds(soundFiles, concurrentLimit = 6) {
    // Create a queue of files to load
    const queue = [...soundFiles];
    const loading = new Set();
    const errors = [];

    function loadNext() {
        // If queue is empty or we've hit the concurrent limit, return
        if (queue.length === 0 || loading.size >= concurrentLimit) {
            return;
        }

        // Get next file from queue
        const file = queue.shift();
        const audio = new Audio();
        
        // Add to loading set
        loading.add(file);

        // Set up event handlers
        audio.addEventListener('canplaythrough', () => {
            console.log(`Loaded: ${file}`);
            loading.delete(file);
            loadNext(); // Try to load another
        }, { once: true });

        audio.addEventListener('error', (e) => {
            console.error(`Error loading ${file}:`, e.message);
            errors.push(file);
            loading.delete(file);
            loadNext(); // Try to load another
        }, { once: true });

        // Start loading
        try {
            audio.src = "mp3/" + file;
        } catch (e) {
            console.error(`Exception loading ${file}:`, e);
            errors.push(file);
            loading.delete(file);
            loadNext(); // Try to load another
        }
    }

    // Start initial batch of loads
    for (let i = 0; i < concurrentLimit; i++) {
        loadNext();
    }

    // Return a promise that resolves when all files are loaded
    return new Promise((resolve) => {
        const checkComplete = setInterval(() => {
            if (queue.length === 0 && loading.size === 0) {
                clearInterval(checkComplete);
                if (errors.length > 0) {
                    console.warn('Some sounds failed to load:', errors);
                }
                resolve(errors);
            }
        }, 100);
    });
}

async function initializeSounds() {
    const errors = await preloadSounds(soundFiles);
    if (errors.length > 0) {
        console.warn('Failed to load some sounds:', errors);
    }
}

console.error('Preloading sounds...');
initializeSounds();

// Only create and show the button if we're on a mobile device
if (/iPhone|iPad|Android/i.test(navigator.userAgent) || window.innerWidth <= 768) {
   setupMobileContinue();
}

</script>

[]

! The following footnote is added to the small print about how to play IF
! on the game's main page:

[INBROWSERPLAY]
Play without downloading anything by following the 'Play In-Browser' link,
using the [INTERPRETER] interpreter. You'll need to have Javascript enabled
on your web browser.
[]

! cBlorb encodes the story file into base64 so that it can be loaded in
! Javascript despite being binary data. The encoding is topped and tailed
! with the following, in order to make the result a valid Javascript function
! call with a string argument:

[BASESIXTYFOURTOP]
vorple.haven.setBase64StoryFile('
[]

[BASESIXTYFOURTAIL]
');
[]

! Outside of the placeholder parts of the manifest, lines beginning '!', or
! lines which contain only white space, are thrown away; so this is a comment.

! Non-comment lines are the names of files which are copied across when the
! release is made. Anything not listed here won't be copied.

roboto.css
vex.css
vorple.min.js.map
vorple.css
vex-theme-plain.css
haven.css
toastr.css
jquery.powertip.css
vorple.min.js
vorple.min.js.LICENSE.txt
